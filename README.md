# hashmap
Flexible hashmap implementation in C using open addressing and linear probing for collision resolution.

### Summary
This project came into existence because there are a notable lack of flexible and easy to use data structures available in C.  Sure, higher level languages have built-in libraries, but plenty of embedded projects or higher level libraries start with core C code.  It was undesirable to add a bulky library like Glib as a dependency to my projects, or grapple with a restrictive license agreement.  Searching for "C hashmap" yielded results with questionable algorithms and code quality, projects with difficult or inflexible interfaces, or projects with less desirable licenses.  I decided it was time to create my own.


### Goals
* **To scale gracefully to the full capacity of the numeric primitives in use.**  E.g. on a 32-bit machine, you should be able to load a billion+ entries without hitting any bugs relating to integer overflows.  Lookups on a hashtable with a billion entries should be performed in close to constant time, no different than lookups in a hashtable with 20 entries.  Automatic rehashing occurs and maintains a load factor of 0.75 or less.
* **To provide a clean and easy-to-use interface.**  C data structures often struggle to strike a balance between flexibility and ease of use.  To this end, I provided a generic interface using void pointers for keys and data, and macros to generate type-specific wrapper functions, if desired.
* **To enable easy iteration and safe entry removal during iteration.**  Applications often need these features, and the data structure should not hold them back.  Both an iterator interface and a foreach function was provided to satisfy various use-cases.  This hashmap also uses an open addressing scheme, which has superior iteration performance to a similar hashmap implemented using separate chaining (buckets with linked lists).  This is because fewer instructions are needed per iteration, and array traversal has superior cache performance than linked list traversal.
* **To use a very unrestrictive software license.**  Using no license was an option, but I wanted to allow the code to be tracked, simply for my own edification.  I chose the MIT license because it is the most common open source license in use, and it grants full rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell the code.  Basically, take this code and do what you want with it.  Just be nice and leave the license comment and my name at top of the file.  Feel free to add your name if you are modifying and redistributing.
